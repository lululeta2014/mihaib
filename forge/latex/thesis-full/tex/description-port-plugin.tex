\section{Port Plugin}

The \emph{Port Plugin} handles signature calls
performed through procedure oriented ports used in a testcase.
The \ac{TTCN-3} values get encoded by the Codec as \verb=TriMessage=s,
and these messages are passed as parameters
to a \ac{TRI} \verb=call= operation, which is carried out by the port plugin.

The port plugin obtains the stored objects from the codec
(corresponding to the keys of type \verb=TriMessage=)
and uses the \emph{signature name} and its \emph{variant} attribute
to obtain the method signature and the type it belongs to.
It then carries out the invocation
and enqueues the return value or the thrown exception.
If a class or method is not found, or if incorrect arguments are supplied,
an appropriate error is reported by the port plugin.


\subsection{Performing method, constructor and accessor calls}

As discussed in section \ref{sec:description-naming-conventions}
certain conventions (of adding prefixes and suffixes) have been used
in order to protect against name clashes between
mangled method names and other names generated by the mapping process
(e.g.\ type names, accessor signatures, constructors, port type names).
As explained there, the presence of an unescaped separator (\verb=__=)
at the end of a name guarantees that it has been generated
and is not a mangled signature name.
Such generated identifiers of interest for the port plugin are:
\begin{itemize}
\item constructors
\item accessors
\end{itemize}
These, together with method calls, are handled by the plugin
in the manner described below.
In all three cases the \emph{variant} attribute
is used to determine the type that the signature belongs to.


\subsubsection{Method calls}

The signature name is unmangled in order to find out
the method name and the types of its parameters.
The port plugin then asks the codec for the stored objects
corresponding to the keys received as \verb=TriMessage=s.
If the method is not static,
the first such key indicates the object on which the invocation is performed.

If the class and method are found, and the parameters are of the correct type,
a separate \emph{Thread} is started to perform the invocation
and the signature call is marked as successful.
Otherwise the Java method call would not be performed
and an appropriate error would be returned for the signature call.

The separate thread carries out the invocation
(by using the \emph{Reflection} \ac{API} provided by the Java library)
and enqueues a key for the returned value or for a thrown exception
to the respective queue on the procedure oriented port.
This is performed by storing the particular returned object in the codec
and enqueuing a \verb=TriMessage= representing the registry key for it.


\subsubsection{Constructor calls}

Constructor calls are carried out in a manner similar to method calls.
After unmangling the constructor signature name,
retrieving the parameters stored in the codec and checking their types,
a new thread is launched
and the port plugin reports that the signature invocation has been successful.
This separate thread performs the actual constructor call
and enqueues a key for the newly created object or for the thrown exception.


\subsubsection{Accessor calls}

Accessor methods also get unmangled to find out the name of the public field
which is to be read from or written to.
After retrieving the stored object (for non static fields)
two slightly different courses of action occur depending on
the type of accessor signature called.
\begin{description}
\item[Getter] methods start a new thread to read the field value
and enqueue the result.
\item[Setter] methods retrieve the stored object containing the new value
for the field and check its type.
Then they start a separate thread
to perform the modification of the field value.
This thread enqueues a \emph{dummy} return value
to signal that the operation has been successfully completed
(similar to a method with a \verb=void= return type).
Testcase code must wait for a \verb=getreply= operation to complete
for the invoked signature
(either a method returning \verb=void= or a setter for a public field)
if the respective operation must be completed
before continuing to execute \ac{TTCN-3} code.
\end{description}


\subsection{Provided meta signatures}

Besides the mapped signatures for the types of interest,
a test developer may need some additional functionality.
This is needed because of the way in which objects (i.e.\ non-primitive types)
may be introduced in Java,
and how they can be created from within \ac{TTCN-3} code.

In both languages values of primitive types (e.g.\ numeric and boolean values)
may be introduced directly using literal values in the source code.
From what has been presented so far,
in order to obtain a handle for a Java object in \ac{TTCN-3} code
the programmer needs to call a \emph{signature} which returns an object
(this may represent a \emph{method}, a \emph{constructor}
or a getter for a \emph{public field}).
In order to obtain the first object, the programmer
may only use primitive types as parameters for this call (if it requires any).

The Java language allows several ways
of introducing objects directly as literals in the source code:
\begin{itemize}
\item Using the keyword \verb=null=
\item Using a \verb=String= literal (e.g.\ \verb="Hello World!"=)
\item \emph{Arrays} are true Java \verb=Object=s
and can be created in several ways
(e.g.\ using \emph{aggregate initialization})%
	\footnote{\texttt{int[] array = \{2, 3, 5, 7, 11\};}}
\end{itemize}

To address this (and other functionality)
a few utility signatures have been predefined.
The meta signatures provided to test developers are shown
in Listing \ref{prog:meta-signatures}.

\begin{program}
\verbatimtabinput{./ttcn3/meta-signatures.ttcn3}
\caption{Meta signatures in the JAVAAUX module\label{prog:meta-signatures}}
\end{program}

\paragraph{\texttt{null}}
Programmers may need to obtain a reference to the Java \verb=null=.
For this reason a meta-signature \verb=makeNull= has been provided.
It is a \emph{meta signature}, i.e.\ it is not mapped to a real method
but is intercepted by the port plugin.
The meta-signatures are defined in the built-in JAVAAUX module.
They will not clash with other mapped signatures
because they are in a separate module.
They are distinguished by the port plugin because of their particular
\emph{encoding variant}\\
\verb=com.testingtech.javaplugin.javaaux=\\
and are then intercepted.

\paragraph{\texttt{String}} objects may be created
by writing a string literal in Java.
The meta signature \verb=makeString= takes a \texttt{universal charstring}
argument and creates a new \verb=String=, returning the handle to it.

\paragraph{Arrays} are truly Java \verb=Object=s.
For this reason, whenever a signature takes an Array parameter
or returns an Array,
the programmer must be allowed to treat it as an \verb=Object=.
Since there is no overloading in \ac{TTCN-3},
Java arrays are treated as \verb=Object=s
and one way of manipulating them is by using methods in the
\verb=java.util.Arrays= class.

\paragraph{Java ``\texttt{==}'' operator}
Programmers may need to check for reference equality
using the Java operator ``\verb|==|''.
The meta signature \verb=eq= has been provided for this purpose.
It takes two object handles as parameters
and has a \verb=boolean= return value.

\paragraph{\texttt{deleteObject}}
is a meta-signature used for removing objects from the registry
kept by the storage codec.
Because there is no way of knowing
when the programmer can no longer address objects
using \ac{TTCN-3} variables (handles)
the objects cannot be automatically deleted from the registry.
If memory consumption becomes an issue,
programmers may use this meta-signature.

\paragraph{\texttt{clearRegistry}}
is a meta-signature which may be used by test developers
when no objects in the registry are of interest any more
(for instance at the end of a long testcase).
This allows memory to be recovered and is more efficient
than deleting all objects one by one (the whole map is discarded
instead of searching for and removing objects individually).
