\section{Building and Walking Trees}


\subsection{Building Intermediate Form Trees}

Syntax-directed applications translate input phrase by phrase
using a single pass over the input.
An IR tree should be:
\begin{description}
\item[Dense] No unnecessary nodes
\item[Convenient] Easy to walk
\item[Meaningful]
Emphasizing operators, operands and the relationship between them,
not artifacts from the grammar.
\end{description}

The structure of intermediate trees should be brain-dead simple.
Tree structure should be insensitive to changes in the grammar
(at least those unrelated to language syntax).

Homogenous trees are built from a single datatype
(we can distinguish the nodes using the \verb=token= field).
Because there is a single type, we can use a normalized child list.

\verbatimtabinput{./code/trees/AST-type-homogenous.java}

By default ANTLR builds homogenous trees of type CommonTree,
but we can easily tell it to create heterogenous trees:

\verbatimtabinput{./code/trees/antlr-heterogenous-syntax.g}


\subsection{P8 Parse Tree}

Describes how a parser recognized an input sentence
(sometimes called a syntax tree).
Interior nodes are rule applications, leaf nodes are token matches.
Fuul of noise (intetrior rule nodes), difficult to walk and transform,
very sensitive to grammar changes.


\subsection{P9 Homogenous AST}

Implements an AST using a ssingle node data type and a normalized child list:
\verbatimtabinput{./code/trees/AST-type-homogenous.java}


\subsection{P10 Normalized Heterogenous AST}

Implements an AST using more than a single node datatype,
but with a normalized child list representation.


\subsection{P11 Irregular Heterogenous AST}

Implements an AST using more than a single node data type
and with an irregular child list.
Instead of a uniform list of children, use specific (named) child fields.


\subsection{Walking and rewriting trees}

\paragraph{Walking Trees and Visitation Order}
Visiting a tree means executing some actions on the nodes of a tree.
The order of node traversal is important.
Three key traversals: preorder, inorder and postorder.
We typically use \emph{depth-first search} starting
at the root of the (sub)tree and recursively walking the children in order.

When the tree walk reaches node \verb=t=, it \emph{discovers} that node
(the execution of \verb=walk()= begins on node \verb=t=).
When \verb=walk()= finishes processing \verb=t= and returns,
it has \emph{finished} with it.

Visiting a node means executing an action
somewhere between discovering and finishing that node.
Depth-first search has a fixed node discovery sequence
but we can generate three traversals (depinding on where we put the actions).

\paragraph{Tree Pattern Matching}
Sometimes we need to do a lot of work on the tree (e.g. generate source code).
Other times we only care about certain sections of the tree:
instead of building a complete grammar we can do pattern mathing.
ANTLR supports tree pattern matching:
it uses a depth-first tree walker that invokes tree grammar rules at each node,
looking for a match.
If a tree pattern doesn't match the current subtree,
ANTLR tries another pattern.
If no patterns match,
it walks to a new node and looks for a matching pattern again.

\paragraph{Tree Walking Patterns} are described below:

\begin{description}
\item[P12 Embedded Heterogenous Tree Walker]
Embedding walking methods in tree nodes is simplest.
Doesn't work well for e.g.\ 50 node types
because walker functionality is distributed among all of them.

\item[P13 External Tree Visitor]
Encapsulates the tree walker in a single class.
Useful for collecting information or simple interpretation
(e.g.\ expression evaluation).
Not well suited to tree pattern matching applications.

\item[P14 Tree Grammar]
External visitors are auto-generated by ANTLR from tree grammars.
Most effective when we need to execute actions in many or most rules.

\item[P15 Tree Pattern Matcher]
Good when executing actions on only a few subtree patterns.
\end{description}


\subsection{P12 Embedded Heterogenous Tree Walker}

Walks heterogenous ASTs using a set of recursive methods
defined within the node class definitions.
Distributes tree-walking code across all node definitions,
so works best when there are only a few node definitions.

\verbatimtabinput{./code/trees/embedded-heterogenous.java}


\subsection{P13 External Tree Visitor}

Encapsulates all tree walking code associated with a particular task
into a single visitor class.
It can walk either heterogenous or homogenous AST nodes.


\subsection{P14 Tree Grammar}

Builds and external visitor (also called tree parser).
We can use P1 to convert tree grammars to tree parsers,
doing an extra mapping for tree structures:

\verbatimtabinput{./code/trees/tree-grammar-impl}

Tree grammars work with both homogenous and heterogenous AST nodes.
They compare token types to distinguish different kinds of nodes.


\subsection{P15 Tree pattern matcher}

Walks trees, triggering actions or tree rewrites
as it encounters tree patterns of interest.
The process of matching and rewriting trees is formally called term rewriting.
Different from using a tree grammar:
\begin{itemize}
\item we specify patterns only for the subtrees we care about
\item we don't need to direct the tree walk
\end{itemize}

We can do tree pattern matching with ANTLR using the \verb=filter= option
in a tree grammar.

\begin{verbatimtab}
e: ^('!' 'true') -> 'false'
 | ^('!' 'false') -> 'true'
 | ^('&&' 'true' x=.) -> $x
 | ^('&&' x=. 'true') -> $x
 ;
\end{verbatimtab}

The \verb=.= (dot) element is a wildcard that matches any node or subtree.
Tree pattern matchers work on both Homogenous ASTs
and Normalized Heterogeneous ASTs.
They require normalized children.

\begin{verbatimtab}
scalarVectorMult
	: ^('*' INT ^(VEC (e+= .)+)) -> ^(VEC ^('*' INT $e)+);
zeroX: ^('*' a=INT b=INT {$a.int==0}?) -> $a;
xZero: ^('*' a=INT b=INT {$b.int==0}?) -> $b;
\end{verbatimtab}

We must specify which rules to apply on the way down and which on the way up.

\begin{verbatimtab}
topdown : scalarVectorMult;
bottomup: zeroX | xZero;
\end{verbatimtab}

ANTLR does a depth-first search,
applying \verb=topdown= rules upon node discovery
and \verb=bottomup= rules upon node finishing.
See pg 142 in the book for a discussion of
why these particular rules are topdown or bottomup.

We must invoke the \verb=downup()= method
(rewrite grammar is \verb=Simplify.g=):
\begin{verbatimtab}
System.out.println("Original tree: " + t.toStringTree());
// Traverse tree down then up, applying rewrite rules.
CommonTreeNodeStream nodes = new CommonTreeNodeStream(t);
Simplify s = new Simplify(nodes);
t = (CommonTree)s.downup(t, true); // walk tree, trace transforms
System.out.println("Simplified tree: " + t.toStringTree());
\end{verbatimtab}
